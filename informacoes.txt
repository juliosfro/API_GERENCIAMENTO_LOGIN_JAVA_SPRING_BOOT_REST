- Java Extension Pack
- Spring Boot Extension Pack que contém dentro:
    * Spring Boot Tools
    * Spring Initializr Java Support
    * Spring Boot Dashboard
- Lombok Annotations Support for VS Code
- Para ver a tela do Java OverView apertar command + shift + p 
e digitar OverView
- Temos que ter o maven instalado no Mac
- Verificar se o gerenciador de dependencias Homebrew está instalado
- Digitar brew -v no terminal do Mac
- Para instalar o maven no Mac basta digitar no terminal brew install maven
- Para verificar se o maven está instalado digitamos: mvn --version
- No momento da criação escolher lombok e restRepositories.

- Vamos criar nosso projeto usando o Spring Tool Suite (STS).
- O primeiro passo é configurar o projeto com tudo que iremos precisar.
- Podemos criar o projeto pelo site do spring.io e importar dentro do STS
ou criar diretamente pelo STS.

docker run --name postbanco -e POSTGRES_PASSWORD=123 -d -p 5432:5432 postgres
MacBook-Air-de-Julio:~ julio$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS                    
9c7254589f45        postgres            "docker-entrypoint.s…"   36 seconds ago      Up 35 seconds             0.0.0.0:5432->5432/tcp 

senha do banco de dados: 123

- pom.xml é o arquivo de configuração do maven onde serão colocadas as dependencias.
- Em um projeto Spring podemos trabalhar com REST e MVC ao mesmo tempo, podemos
trabalhar com vários tipos de arquitetura dentro de um mesmo projeto.
- application.properties é o arquivo onde fica todas as configurações para se conectar
no banco de dados via driver JDBC, como string de conexão, porta, usuario, senha 
e etc.
- O arquivo application.properties fica no seguinte caminho:
     /src/main/resources/application.properties

- É necessário pesquisar o dialeto do banco de dados para o Hibernate.
- Exemplo de passagem de parametro na url:
    http://localhost:8080/usuario/?nome=Julio

@RestController /* Para a classe aceitar métodos REST */
@RequestMapping(value = "/usuario") /* Estou mapeando para /usuario */
public class IndexController {

	@GetMapping(value = "/", produces = "application/json") /* Estou mapeando para a raíz de /usuario/. */
	/* Vou receber um parametro chamado nome do tipo String. */
	public ResponseEntity init(@RequestParam(value = "nome") String nome ) {
		return new ResponseEntity("Olá usuário REST Spring Boot seu nome é: " + nome, HttpStatus.OK);
	}
}

- Acima está um exemplo básico de chamada de método REST com passagem de parametro na url.
- Para não dar erro é sempre necessário assumir um valor padrão.
- Para passar mais de um parametro na url usamos o &, veja abaixo:
    http://localhost:8080/usuario/?nome=Julio&salario=3000

 Retornando usuário em JSON para a tela
----------
- Para consultar usuarios usamos o método GET.

Criando nosso serviço POST e efetuando um cadastro de usuário
---------
- Para cadastrar um usuário usamos o método POST.
- Exemplo de objeto no formato json a ser passado em uma requisição POST
        
        {
        "id": null,
        "login": "marcela@gmail.com",
        "senha": "123",
        "nome": "Marcela Misale"
        }

- O id deve ser passado como nulo para não dar erro de violação de constraint, 
pois no banco de dados o mesmo está como autoincremento.

 Criando a atualização de cadastro com o PUT

 - Quando usamos o eclipse e criamos um projeto com o maven para carregar as 
 dependencias acontece que o eclipse usa o maven interno dele,  quando é interno
 não conseguimos usar vários recursos que precisamos no desenvolvimento.
 - O eclipse também vem com o servidor TomCat interno, também podemos usar o 
 servidor TomCat de forma externa no eclipse.
 - Com o Spring Boot se quisermos gerar um arquivo War ou então um Jar 
 autoexecutável para implantar a nossa aplicação em algum local então iremos 
 precisar do maven mas não o que está dentro do eclipse.
 - Precisaremos instalar o maven externamente e por linha de comando dar o 
 comando de build para gerar o arquivo war/jar para então implantar em algum
 servidor.
 
 export JAVA_HOME=/usr/local/Cellar/openjdk/15.0.1/libexec/openjdk.jdk/Contents/Home
 echo ${JAVA_HOME}

 export MAVEN_HOME=/usr/local/Cellar/maven/3.6.3_1
 echo ${MAVEN_HOME}

 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH

 export CATALINA_HOME=/usr/local/Cellar/tomcat/9.0.43
 catalina start 

- Para verificar a versão do maven instalada:  mvn -v
- Para verificar a versão do TomCat instalado: catalina version

Configurando o contexto da nossa aplicação

- No arquivo application.properties adicionamos a seguinte linha abaixo: 
    server.servlet.context-path=/cursospringrestapi
- Para acessar ficara da seguinte forma: http://localhost:8080/cursospringrestapi/
- É importante configurar o contexto para sabermos qual projeto estamos 
acessando.

Gerando Jar executável da Aplicação Spring Boot

- O Jar e o War que são arquivos de implantação.
- Para gerar o arquivo de implantação digitamos: mvn package 
- O arquivo de implantação será gerado dentro da pasta target
- O comando mvn package deve ser executado um diretório acima da pasta target
- Para rodar o arquivo de implantação digitamos:
    java -jar cursospringrestapi-0.0.1-SNAPSHOT.jar
- Podemos disponibilizar o arquivo jar para um amigo por exemplo, mas 
ele deve ter o sistema gerenciador de banco de dados instalado na máquina dele.

Gerando WAR e Implantando no Servidor

- Através do arquivo pom.xml decidimos que tipo de arquivo será gerado
através da tag packaging, veja abaixo:
    
    <packaging>jar</packaging>

- Para gerar o arquivo war é o mesmo comando que usamos para gerar o 
arquivo jar, digitamos mvn package um diretório acima da pasta target.
- O arquivo será gerado dentro da pasta target.

    cd /usr/local/Cellar/tomcat/9.0.43/libexec/webapps

- Para acessar o projeto basta somente iniciar o servidor TomCat
com o comando catalina start e acessar a seguinte url:
    http://localhost:8080/cursospringrestapi

- Basta colocar o arquivo war do projeto dentro da pasta webapps do servidor
TomCat.

Criando Relacionamento um para muitos

- http://localhost:8080/cursospringrestapi/usuario/

- Por enquanto temos apenas um objeto simples em nosso banco de dados.
- Vamos fazer um relacionamento um para muitos que é o mais comum quando
criamos um objeto simples.

 Implementando o END-POINT de atualização

    select usuario.id, usuario.login, usuario.nome, usuario.senha, telefone.numero
    from usuario inner join telefone
    on usuario.id = telefone.usuario_id;

    select * from telefone;

 Implantando a API na hospedagem

 - No curso de formação de Java Web temos os módulos que ensinam a fazer hospedagem.
 
 cd /Users/julio/Library/Mobile\ Documents/com\~apple\~CloudDocs/cursos/backend-spring-boot-rest/cursospringrestapi

 - Rodar o comando: mvn package
 - Sempre deixar o nome do arquivo de implantação com o mesmo nome do contexto.
 - Exemplo do nome do contexto:

    server.servlet.context-path=/cursospringrestapi 

- O nome do contexto fica no arquivo application.properties
- Temos que colocar o username e a senha do banco que estão na hospedagem.
- Descompactar o arquivo .war e editar o arquivo application.properties com o 
notepad++ por exemplo e colocar os dados do banco da hospedagem, usuario e senha.
- É necessário criar o banco de dados no servidor da hospedagem.
- Pode ficar localhost o inicio da string da conexão com o banco de dados 
pois vai subir localmente no servidor da hospedagem.
- Devemos saber como registrar dominio e contratar hospedagem.
- É essencial estudar o módulo de hospedagem.
- Devemos habilitar a API para aceitar solicitação de outra máquina depois
que ela já estiver hospedada, questões de segurança.
- Para ter o https de conexão segura deve ser contratado o plano de ssl.

Cross Origin - Controle de acesso a API

- Por motivos de segurança, os navegadores proíbem chamadas ajax para 
recursos que residem fora da origem atual.
- Como uma API REST é feita para que vários clientes possam acessar então
surge o controle de acesso denominado CORS.
- Podemos fazer bloqueios e liberações bem customizadas para cada end-point,
para cada controller REST e seus end-point ou até mesmo para todo o projeto 
e seus end-points.

- Podemos liberar uma API somente para um determinado endereço, somente
para a empresa de fulano de tal por exemplo.
- É possível liberar apenas um end-point para uma empresa por exemplo.
- Toda a parte de segurança é bem customizada.

 Cross Origin - Testando a requisição AJAX

 - Toda API REST em Spring por default bloqueiam chamadas Ajax do jQuery.
 - Se tiver apenas a anotação @CrossOrigin no cabeçalho da classe controller
 significa que pode ser acessada de qualquer lugar, ou seja, através de 
 qualquer mecanismo, através de chamadas Ajax do jQuery por exemplo.
 - Podemos amarrar um servidor especifico a nossa API, pode ser por 
 dominio de url por exemplo.

 - Veja abaixo um exemplo:
    @CrossOrigin(origins = "https://www.projetojavaweb.com/")

- Podemos usar a anotação @CrossOrigin nos end-points, podemos restringir
o acesso ao método de consultar todos os usuários para apenas um servidor
por exemplo.
- Para liberar o acesso a todos deve-se colocar a anotação em cima no 
cabeçalho do controller, mas se for apenas para um end-point especifico
então deve-se retirar a anotação do cabeçalho do controller e jogar no
método que deseja liberar além de estabelecer critérios de liberação.

Configuração Global

- Podemos ter uma API gigante com vários métodos e mais de cem controllers 
por exemplo.
- Podemos definir todas as configurações de forma global para a nossa aplicação
inteira, isto é, incluindo todas os controllers e end-points, isso pode ser 
feito através da classe que possuí a anotação @SpringBootApplication e também
o método main()

Configuração Centralizada e Global

- Podemos ter um controller para cada regra de negócio.
- É possível centralizar tudo aonde tem o método SpringApplication que 
inicializa toda a aplicação.
- Precisaremos implementar uma interface chamada WebMvcConfigurer na classe
que da o start incial na aplicação, veja abaixo um exemplo:

    public class CursospringrestapiApplication implements WebMvcConfigurer 

- Através do método addCorsMappings podemos fazer todas as configurações, 
veja abaixo:

    /* Configuração Global de controle de acesso que reflete em todo o sistema. */
	@Override
	public void addCorsMappings(CorsRegistry registry) {

		/* Para liberar acesso a todos os controllers e end-points. */
		/* registry.addMapping("/**"); */

		/* Para todos os end-points que estao dentro do controller /usuario */
		/* Podemos restringir quais tipos de requisicoes que podem ser enviadas */
		/* É possivel restringir por origem, ou seja, quem esta requisitando. */
		registry.addMapping("/usuario/**").allowedMethods("POST").allowedOrigins("https://www.jdvtreinamentos.com.br");
	}

Spring Security - Configurando ROLE


- Vamos começar a configuração do Spring Security
- Só vamos poder acessar nossos métodos da API se for enviado junto um 
login e uma senha, mais adiante vamos ver sobre jwt que é autenticação por
token.
- Além do token tem usuario e senha para fazer a validação da API.
- Quando estamos trabalhando com REST a camada de front-end não tem uma sessão 
amarrada igual jsf, jsp ou seja um sistema MVC. O servidor não tem o controle
que determinado usuário está conectado, então toda requisição tem que ser validada
com usuario, senha e o token que é um hash (uma senha bem grande criptografada).
- Primeiro precisamos configurar todo o Spring Security.
- No Spring Security as nomenclaturas começam com Role que são os papéis, por
exemplo é um administrador, super-visor, gerente, secretário e etc.
- precisamos ter a dependencia do Spring Security dentro do pom.xml para o 
maven poder baixa-la.

- Devemos implementar a interface GrantedAuthority do Spring Security
na nossa classe Role.
- Devemos conectar a classe de Usuario com a classe de Role e mapear as 
tabelas corretamente no banco de dados.

 Spring Security - Configurando Usuário

 - Papéis são usados para permitir ou esconder acessos, esconder url e etc.
 - Para linkar a classe Usuario com a classe Role devemos implementar a 
 interface UserDetails no lugar da interface Serializable na classe Usuario.
 - A interface UserDetails é a interface do Spring Security para trabalhar
 com autorizações, é uma interface que se conecta com todo o núcleo do Spring
 Security.
 - Após implementar a interface UserDetails na classe Usuario seremos obrigados
 a implementar todos os métodos que a interface UserDetails propõe.
 - Por padrão todos os métodos do contrato da interface UserDetails venhem 
 desabilitados como false.
 
  Configurando o Repository e o Service

  - Agora vamos configurar o Repository e o Service, sendo que o service vai
  prover um serviço que vai ligar com um repository com acesso ao banco de dados.
  
   Configurando o Spring Security

   - Tudo antes de chegar no sistema vai ser interceptado pelo Spring Security,
   então ele vai fazer a validação, vai verificar se o usuario pode acessar ou 
   não e etc.

 JSON Web Token (JWT) - Introdução ao JWT

 - O JWT é um padrão (RFC-7519) de mercado que define como transmitir e 
 armazenar objetos JSON de forma compacta e segura entre diferentes aplicações
 usando a arquitetura REST ou Microserviços sendo RESTFUL e JSON.

 - Os dados nele contidos podem ser validados a qualquer momento pois o token
 é assinado digitalmente e sua validação é feita a cada requisição.

 - Ele é formado por três sessões: Header, Payload e Signature.

 - Header: Define informações sobre o tipo do token, nesse caso JWT.
 - Payload: Contém as informações da entidade autorizada no caso o usuário que
 fez o login.
 - Signature: A assinatura é a junção de todas as partes somando a uma chave de 
 assinatura ou certificado e tudo é codificado em Base64.

- Vantagens: Permite a comunicação segura entre diferentes sistemas e integrações,
também evita que os dados sejam capturados por rede e manipulados de forma errada 
por alguém com más intenções.
- Vamos unir as validações de login com usuario e senha com o JWT.
- As vezes não precisa do usuario e senha mas é obrigatório o token (JWT), pois 
ele tem toda uma assinatura, cabeçalho, informações, é possível validar até 
com certificado digital.
- Se eu fosse gerar uma nota fiscal eu teria que enviar um JSON para o 
servidor reconhecer que eu tenho autorização para gerar uma nota fiscal. 

- Em integrações com APIs sempre tem um token por trás.
- O JWT é gerado somente depois do usuario e senha serem validados, então
o servidor retorna o JWT para o cliente (navegador), depois o cliente 
responde para o servidor devolvendo o JWT para confirmar que ele ainda continua
logado.
- O JWT pode ser devolvido para o servidor no cabeçalho da requisição se for
por método GET ou no corpo da requisição se for por método POST.
- Quando trabalhamos com JWT não precisamos validar o usuário pela segunda vez
pois no token já esta a validação completa.
- Toda vez que for fazer uma requisição após o login será necessário entregar o token.

 JSON Web Token (JWT) - Estrutura de classes do projeto

 - xxx...